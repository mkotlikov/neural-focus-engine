<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Focus Engine | Generative Phase-Locking</title>
    <style>
        :root {
            --bg: #0f111a;
            --surface: #1a1d2d;
            --primary: #7c4dff;
            --secondary: #00e5ff;
            --text: #e0e0e0;
            --text-dim: #8b9bb4;
        }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            width: 90%;
            max-width: 600px;
            background: var(--surface);
            padding: 2rem;
            border-radius: 24px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            margin: 0;
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p.subtitle {
            margin: 0.5rem 0 0;
            color: var(--text-dim);
            font-size: 0.9rem;
        }

        /* Visualizer */
        canvas {
            width: 100%;
            height: 120px;
            background: #11131e;
            border-radius: 12px;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* Controls */
        .controls {
            display: grid;
            gap: 1.5rem;
        }

        .modes {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            padding: 4px;
            border-radius: 12px;
        }

        button.mode-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        button.mode-btn.active {
            background: var(--surface);
            color: var(--secondary);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--text-dim);
            font-weight: 600;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(124, 77, 255, 0.4);
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        /* New Select Style */
        select {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: var(--text);
            font-family: inherit;
            cursor: pointer;
            outline: none;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }

        select:hover {
            border-color: var(--primary);
        }

        option {
            background: var(--surface);
            color: var(--text);
        }

        .play-btn {
            width: 100%;
            padding: 1rem;
            border: none;
            border-radius: 12px;
            background: var(--primary);
            color: white;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: filter 0.2s;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .play-btn:hover {
            filter: brightness(1.1);
        }

        .play-btn.playing {
            background: #cf3d3d;
        }

        .info {
            margin-top: 1.5rem;
            font-size: 0.8rem;
            color: var(--text-dim);
            text-align: center;
            line-height: 1.4;
        }
    </style>
</head>

<body>

    <div class="container">
        <header>
            <h1>Neural Focus Engine</h1>
            <p class="subtitle">Generative Music • Neural Phase-Locking • Infinite</p>
        </header>

        <canvas id="visualizer"></canvas>

        <div class="controls">
            <div class="modes">
                <button class="mode-btn" onclick="setMode('gamma')">Create</button>
                <button class="mode-btn active" onclick="setMode('focus')">Focus</button>
                <button class="mode-btn" onclick="setMode('relax')">Relax</button>
                <button class="mode-btn" onclick="setMode('sleep')">Sleep</button>
            </div>

            <div class="slider-group">
                <div class="slider-header">
                    <span>Soundscape</span>
                </div>
                <select id="styleSelect" onchange="setStyle(this.value)">
                    <option value="ambient">Ambient Drift</option>
                    <option value="active">Neuro Flow (Fast)</option>
                    <option value="ethereal">Ethereal Planes</option>
                    <option value="techno">Neural Techno</option>
                    <option value="noise">Focus Static (Pink Noise)</option>
                </select>
            </div>

            <div class="slider-group">
                <div class="slider-header">
                    <span>Neural Intensity</span>
                    <span id="intensityVal">50%</span>
                </div>
                <input type="range" min="0" max="100" value="50" id="intensitySlider">
            </div>

            <button class="play-btn" id="playBtn">
                <span id="playIcon">▶</span> <span id="playText">Initialize Engine</span>
            </button>
        </div>

        <div class="info">
            Frequency: <span id="freqDisplay" style="color:var(--secondary)">14 Hz (Beta)</span><br>
            Neural phase locking active. Audio modulated to induce synchronization.
        </div>
    </div>

    <script>
        // --- AUDIO ENGINE CONTEXT ---
        let audioCtx;
        let isPlaying = false;

        // --- NODES ---
        let masterGain;
        let neuralModulatorGain; // The "Gate" that pulses the volume
        let neuralLFO;           // The oscillator controlling the gate
        let reverbNode;

        // --- GENERATIVE STATE ---
        let nextNoteTime = 0;
        let lookahead = 25.0; // ms
        let scheduleAheadTime = 0.1; // s
        let timerID;
        let activeOscillators = [];
        let noiseBuffer; // Reusable buffer for noise

        // --- CONSTANTS ---
        // Pentatonic Scale frequencies (C Major Pentatonic) extended across octaves
        const SCALE = [
            130.81, 146.83, 164.81, 196.00, 220.00, // C3 - A3
            261.63, 293.66, 329.63, 392.00, 440.00, // C4 - A4
            523.25, 587.33, 659.25, 783.99, 880.00  // C5 - A5
        ];

        const MODES = {
            focus: { freq: 14, type: 'sawtooth', label: '14 Hz (Beta)' }, // Alert, sharp pulses
            relax: { freq: 10, type: 'sine', label: '10 Hz (Alpha)' },    // Calm, smooth pulses
            sleep: { freq: 2, type: 'sine', label: '2 Hz (Delta)' },      // Deep, slow waves
            gamma: { freq: 40, type: 'sawtooth', label: '40 Hz (Gamma)' }  // Peak concentration
        };

        let currentMode = 'focus';
        let currentStyle = 'ambient';

        // --- UI ELEMENTS ---
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const playBtn = document.getElementById('playBtn');
        const playText = document.getElementById('playText');
        const playIcon = document.getElementById('playIcon');
        const intensitySlider = document.getElementById('intensitySlider');
        const intensityVal = document.getElementById('intensityVal');
        const freqDisplay = document.getElementById('freqDisplay');
        const modeBtns = document.querySelectorAll('.mode-btn');

        // --- INITIALIZATION ---

        async function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            // 1. Create Master Output Chain
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.5;

            // 2. Create Neural Modulator (The Core Tech)
            // The music goes into this gain node, and this gain node is automated by the LFO
            neuralModulatorGain = audioCtx.createGain();
            neuralModulatorGain.gain.value = 1.0;

            // 3. Create Reverb (Impulse Response)
            reverbNode = audioCtx.createConvolver();
            reverbNode.buffer = await createImpulseResponse();

            // 4. Wiring: Music -> Reverb -> NeuralGate -> Master -> Out
            // (We mix dry and wet signal for the generative synth separately)

            reverbNode.connect(neuralModulatorGain);
            neuralModulatorGain.connect(masterGain);
            masterGain.connect(audioCtx.destination);

            // 5. Start the Neural LFO
            startNeuralLFO();

            // 6. Generate White Noise Buffer (cached)
            const bufferSize = audioCtx.sampleRate * 2; // 2 seconds
            noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
        }

        // --- NEURAL PHASE LOCKING LOGIC ---

        function startNeuralLFO() {
            if (neuralLFO) neuralLFO.stop();

            // The LFO (Low Frequency Oscillator) that creates the "beat"
            neuralLFO = audioCtx.createOscillator();
            neuralLFO.frequency.value = MODES[currentMode].freq;
            neuralLFO.type = MODES[currentMode].type; // Set shape (sine/sawtooth)

            // To modulate gain (volume), we need to map the LFO (-1 to 1) 
            // to a Gain value (e.g., 0.5 to 1.0).
            // We use a separate GainNode to control the *depth* of this modulation.

            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 0; // Starts at 0, controlled by slider

            // Connect LFO -> LfoGain -> NeuralModulatorGain.gain
            neuralLFO.connect(lfoGain);
            lfoGain.connect(neuralModulatorGain.gain);

            neuralLFO.start();

            // Store reference to lfoGain so slider can change it
            neuralLFO.depthNode = lfoGain;

            updateIntensity(); // Apply initial slider value
        }

        function setStyle(style) {
            currentStyle = style;
        }

        function updateIntensity() {
            if (!neuralLFO || !neuralLFO.depthNode) return;

            // Slider 0-100 mapped to modulation depth 0.0 - 0.5
            // If depth is 0.5, gain oscillates between 1.0 +/- 0.5 => (0.5 to 1.5)
            // Note: We want to dip volume, not clip it. 
            // A safer modulation is subtractive or centered. 
            // Here we simply modulate around the base gain.
            const val = parseInt(intensitySlider.value) / 100;
            intensityVal.innerText = `${parseInt(intensitySlider.value)}%`;

            // Smooth transition
            const now = audioCtx.currentTime;
            neuralLFO.depthNode.gain.setTargetAtTime(val * 0.3, now, 0.1);
        }

        function setMode(mode) {
            currentMode = mode;

            // Update UI
            modeBtns.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            freqDisplay.innerText = MODES[mode].label;

            // Update Audio
            if (audioCtx && neuralLFO) {
                const now = audioCtx.currentTime;
                // Ramp frequency smoothly
                neuralLFO.frequency.setTargetAtTime(MODES[mode].freq, now, 1.0);
                neuralLFO.type = MODES[mode].type; // Update shape instantly
            }
        }

        // --- GENERATIVE MUSIC ENGINE ---

        function playNote(time) {
            // SPECIAL HANDLER FOR NOISE
            if (currentStyle === 'noise') {
                const source = audioCtx.createBufferSource();
                source.buffer = noiseBuffer;
                source.loop = true;

                // Color the noise (Lowpass filter makes it Pink/Brown)
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200 + Math.random() * 400; // Varying 'wind' tones

                const noiseGain = audioCtx.createGain();

                // Fade in/out for continuous texture
                const duration = 2.0 + Math.random();
                const attack = 1.0;
                const release = 1.0;

                noiseGain.gain.setValueAtTime(0, time);
                noiseGain.gain.linearRampToValueAtTime(0.15, time + attack);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, time + duration); // Fade out

                // Connections
                source.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(reverbNode);

                source.start(time);
                source.stop(time + duration + 0.5);

                return; // Skip standard oscillator logic
            }

            // 1. Pick a random note from scale
            let noteScale = SCALE;

            if (currentStyle === 'active') {
                noteScale = SCALE.slice(5); // Remove lowest octave
            } else if (currentStyle === 'ethereal') {
                noteScale = SCALE.slice(7); // ONLY high octaves
            } else if (currentStyle === 'techno') {
                // Bias towards Bass + Mids
                noteScale = SCALE.slice(0, 10);
            }

            // Techno bass override
            if (currentStyle === 'techno' && Math.random() < 0.3) {
                noteScale = [SCALE[0], SCALE[3]]; // Force root or 5th bass sometimes
            }

            const freq = noteScale[Math.floor(Math.random() * noteScale.length)];

            // DURATION & ENVELOPE LOGIC
            let duration, attack, release, wave1, wave2, vol;

            if (currentStyle === 'ambient') {
                duration = 2 + Math.random() * 4;
                attack = duration * 0.2;
                release = duration;
                wave1 = 'sine';
                wave2 = 'triangle';
                vol = 0.05 + Math.random() * 0.05;

            } else if (currentStyle === 'ethereal') {
                duration = 4.0 + Math.random() * 4.0;
                attack = 2.0;
                release = 5.0; // Massive tail
                wave1 = 'sine';
                wave2 = 'sine'; // Pure tones
                vol = 0.03; // Quiet

            } else if (currentStyle === 'techno') {
                duration = 0.15;
                attack = 0.001;
                release = 0.2; // Plucky
                wave1 = 'square';
                wave2 = 'sawtooth'; // Aggressive
                vol = 0.04;

            } else { // active
                duration = 0.3 + Math.random() * 0.2;
                attack = 0.01;
                release = 0.4;
                wave1 = 'triangle';
                wave2 = 'sawtooth';
                vol = 0.03 + Math.random() * 0.03;
            }

            // 2. Create Oscillators
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();

            osc1.type = wave1;
            osc2.type = wave2;

            osc1.frequency.value = freq;

            // Detune logic
            if (currentStyle === 'ethereal') {
                osc2.frequency.value = freq * 1.01; // Shimmer
            } else if (currentStyle === 'techno') {
                osc2.frequency.value = freq * 0.5; // Sub oscillator octave down!
            } else {
                osc2.frequency.value = freq * 1.005;
            }

            // 3. Envelope (ADSR)
            const noteGain = audioCtx.createGain();

            noteGain.gain.setValueAtTime(0, time);
            noteGain.gain.linearRampToValueAtTime(vol, time + attack);
            noteGain.gain.exponentialRampToValueAtTime(0.001, time + release);

            // 4. Connect
            osc1.connect(noteGain);
            osc2.connect(noteGain);
            noteGain.connect(reverbNode);

            // 5. Start/Stop
            osc1.start(time);
            osc2.start(time);
            osc1.stop(time + release + 1);
            osc2.stop(time + release + 1);

            // Cleanup visualization list
            activeOscillators.push({
                freq: freq,
                startTime: time,
                duration: (currentStyle === 'ambient' || currentStyle === 'ethereal') ? duration : release,
                peak: vol
            });
        }

        function scheduler() {
            while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
                // Determine density based on mode AND style
                let nextGap;

                if (currentStyle === 'ambient') {
                    const density = currentMode === 'sleep' ? 3.0 : 1.5;
                    nextGap = (Math.random() * density) + 0.5;
                    playNote(nextNoteTime);

                } else if (currentStyle === 'noise') {
                    nextGap = 1.5; // Consistent overlap (duration is ~2-3s)
                    playNote(nextNoteTime);

                } else if (currentStyle === 'ethereal') {
                    // Very sparse
                    nextGap = 2.0 + Math.random() * 3.0;
                    playNote(nextNoteTime);

                } else if (currentStyle === 'techno') {
                    // Grid based 
                    const sixteenth = 0.125; // 120 BPM roughly
                    // Simple probabilistic sequencer
                    const r = Math.random();
                    if (r > 0.1) { // 90% chance to play note (busy)
                        playNote(nextNoteTime);
                    }
                    nextGap = sixteenth;
                    // Add slight groove?
                    if (Math.random() > 0.8) nextGap = sixteenth * 2; // Eighth note gap

                } else { // active
                    const density = 0.15;
                    nextGap = (Math.random() * 0.2) + density;
                    playNote(nextNoteTime);
                }

                nextNoteTime += nextGap;
            }
            timerID = window.setTimeout(scheduler, lookahead);
        }

        // --- UTILITIES ---

        // Generates a synthetic reverb impulse response (Algorithmic Reverb)
        async function createImpulseResponse() {
            const sampleRate = audioCtx.sampleRate;
            const length = sampleRate * 3.0; // 3 seconds tail
            const impulse = audioCtx.createBuffer(2, length, sampleRate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                // Exponential decay noise
                const decay = Math.pow(1 - i / length, 5);
                left[i] = (Math.random() * 2 - 1) * decay;
                right[i] = (Math.random() * 2 - 1) * decay;
            }
            return impulse;
        }

        // --- VISUALIZATION ---

        function draw() {
            requestAnimationFrame(draw);

            // Clear
            ctx.fillStyle = '#11131e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!isPlaying) return;

            const w = canvas.width;
            const h = canvas.height;
            const now = audioCtx.currentTime;

            // 1. Draw Modulator Wave (The "Brain" Pulse)
            ctx.beginPath();
            ctx.strokeStyle = '#2a2d3d';
            ctx.lineWidth = 2;

            const lfoFreq = MODES[currentMode].freq;
            for (let x = 0; x < w; x++) {
                // Simulate the LFO wave
                const y = h / 2 + Math.sin(x * 0.05 + now * lfoFreq) * (h / 3);
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // 2. Draw Active Notes (The "Music")
            activeOscillators = activeOscillators.filter(o => now < o.startTime + o.duration);

            activeOscillators.forEach(osc => {
                const age = (now - osc.startTime) / osc.duration; // 0 to 1
                const x = (osc.freq / 1000) * w; // Map freq to X

                // Fade in/out alpha
                let alpha = 0;
                if (age < 0.2) alpha = age / 0.2;
                else alpha = 1 - (age - 0.2) / 0.8;

                ctx.fillStyle = `rgba(124, 77, 255, ${alpha})`;

                const radius = 5 + (osc.peak * 200);

                ctx.beginPath();
                ctx.arc(x, h / 2, radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        draw(); // Start loop

        // --- EVENT LISTENERS ---

        intensitySlider.addEventListener('input', updateIntensity);

        playBtn.addEventListener('click', async () => {
            if (!audioCtx) await initAudio();

            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }

            isPlaying = !isPlaying;

            if (isPlaying) {
                // START
                playText.innerText = "Stop Engine";
                playIcon.innerText = "■";
                playBtn.classList.add('playing');

                nextNoteTime = audioCtx.currentTime;
                scheduler();

                // Fade in master
                masterGain.gain.setTargetAtTime(0.5, audioCtx.currentTime, 1);
            } else {
                // STOP
                playText.innerText = "Initialize Engine";
                playIcon.innerText = "▶";
                playBtn.classList.remove('playing');

                clearTimeout(timerID);
                masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
            }
        });

    </script>
</body>

</html>